% !TEX root = kocher-topk-indexing.tex

\emph{Top-$k$ Subtree Similarity Queries.} TASM-Dynamic~\cite{zhang-siam-1989,augsten-icde-2010}, a simple solution for the top-$k$ subtree similarity problem, computes the edit distance between the query $Q$ and the entire document $T$ using dynamic programming. As a side product, the edit distances between the query and all subtrees of the document are computed. This approach requires $\BigO ( \sizeOf{Q}^2\sizeOf{T} )$ time and $\BigO ( \sizeOf{Q}\sizeOf{T} )$ space~\cite{demaine-talg-2009}.
%
Augsten et al.~\cite{augsten-icde-2010, augsten-tkde-2011} show that the maximum subtree size that must be considered is $\tau = 2\sizeOf{Q} + k$. They develop the \tasmpostorder{} algorithm that runs in $\BigO ( \sizeOf{Q}^2 + \sizeOf{Q}k )$ space, i.e., the memory is independent of the document size. TASM-Postorder does not use an index and must scan the document for each query. We empirically compare our solution to \tasmpostorder{}.

Cohen~\cite{cohen-sigmod-2013} proposes \structuresearch{}, the first index-based method for top-$k$ subtree similarity queries. The index identifies repeating subtree patterns to reduce the number of redundant edit distance computations. \structuresearch{} does not need to scan the document at query time and outperforms \tasmpostorder{} in terms of runtime. However, \structuresearch{} requires a large index, which can be quadratic in the document size. The document is the database, which may be large (e.g., \swissprot{} has $\sizeOf{T} = 479$M nodes). Our \shincone{} algorithm requires only a linear-size index.
%
We empirically compare \structuresearch{} to \shincone{}. Our solution builds a smaller index,  building the index is faster, and in most settings we outperform \structuresearch{} in terms of query response time, often by orders of magnitude.

\emph{XML Indexing Techniques.} Inverted lists and data structures similar to our node index have also been used to index XML documents~\cite{grust-sigmod-2002, kaushik-sigmod-2004}. These works solve a different problem (answering resp.\ ranking XPath queries) and do not consider the tree edit distance. Further, our index access methods are different: we access the inverted lists partition by partition based on an edit distance bound and build the partitions on the fly while accessing them.

\emph{Tree Edit Distance.} The classical tree edit distance algorithm by Zhang and Shasha~\cite{zhang-siam-1989} runs in $\BigOOf{n^4}$ time and $\BigOOf{n^2}$ space for trees with $n$ nodes; for flat trees of depth $\BigOOf{\log n}$ the algorithm runs efficiently in $\BigOOf{n^2\log^2 n}$ time. Bille~\cite{bille-tcs-2005} surveys classical edit distance algorithms.
%
Newer developments include the algorithm by Demaine et al.~\cite{demaine-talg-2009}, which reduces the runtime to $\BigOOf{n^3}$, and AP-TED$^+$ by Pawlik and Augsten~\cite{pawlik-infsys-2016}. AP-TED$^+$ analyzes the input trees and dynamically computes the optimal evaluation strategy. While the runtime complexity remains cubic, this worst case can often be avoided. Despite all efforts, computing the edit distance remains expensive. We introduce the candidate score to rank  subtrees, verify promising candidates first, and thus reduce the number of expensive edit distance computations.

\emph{Related Problem Definitions}. Related but different problems include, for example, XML duplicate detection~\cite{puhlmann-edbt-2016,calado-book-2010}, approximations of the tree edit distance~\cite{yang-sigmod-2005, augsten-vldb-2005}, tree similarity joins~\cite{tang-vldb-2015}, top-$k$ similarity joins for sets~\cite{xiao-icde-2009}, and top-$k$ queries over relational data~\cite{ilyas-acmcs-2008}.

Cohen et al.~\cite{cohen-icde-2014} introduce a top-$k$ algorithm that works for both ordered and unordered trees. In near linear time, the algorithm retrieves the top-$k$ subtrees in a document w.r.t.\ a so-called profile distance function. A profile distance function projects tree features to a multiset and evaluates the distance between feature multisets; examples include $pq$-grams~\cite{augsten-vldb-2005} and binary branches~\cite{yang-sigmod-2005}. The algorithm by Cohen et al.~\cite{cohen-icde-2014} solves a related but different problem and does not provide edit distance guarantees on the ranking.

In their TA algorithm, Fagin et al.~\cite{fagin-pods-2001, fagin-jcss-2003} process ranked lists of items sorted by some local score. The global score of an item is computed based on the respective local scores. The goal is to find the $k$ items with the highest global score. Akbarinia et al.~\cite{akbarinia-vldb-2007} improve the efficiency of TA by minimizing the number of list accesses.
%
Theobald et al. propose TA-based solutions to answer probabilistic top-$k$ queries~\cite{theobald-vldb-2004}, efficiently expand queries~\cite{theobald-sigir-2005}, and build an efficient top-$k$ query processing system for semi-structured data~\cite{theobald-vldbj-2008}. We introduce the candidate score on subtrees, but we do not merge ranked lists. The challenge in our setting is to rank candidates efficiently and produce the head of the ranked list without generating the tail.
